package com.boomerangbandits.api;

import com.boomerangbandits.BoomerangBanditsConfig;
import com.boomerangbandits.api.models.AuthResponse;
import com.boomerangbandits.api.models.LeaderboardEntry;
import com.boomerangbandits.api.models.MemberProfile;
import com.boomerangbandits.api.models.PlayerProfile;
import com.boomerangbandits.api.models.PluginConfigResponse;
import com.boomerangbandits.api.models.RankSummaryResponse;
import com.boomerangbandits.util.DevModeDataProvider;
import com.google.gson.Gson;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

/**
 * HTTP client for the Boomerang Bandits backend API.
 *
 * All calls are async (OkHttp enqueue). Never blocks the game thread.
 * In dev mode, returns hardcoded data from DevModeDataProvider.
 *
 * Error handling: tracks consecutive failures. After maxRetryAttempts,
 * enters degraded mode (stops retrying, uses cached data).
 */
@Slf4j
@Singleton
public class ClanApiService {

    @Inject private @Named("boomerang") OkHttpClient httpClient;
    @Inject private Gson gson;
    @Inject private BoomerangBanditsConfig config;

    private final AtomicInteger consecutiveFailures = new AtomicInteger(0);
    /**
     * -- GETTER --
     *
     * @return true if the service has exceeded max retry attempts
     *         and is operating in degraded mode (using cached data)
     */
    @Getter
    private volatile boolean degraded = false;

    /** Auth token generated by the plugin on first login, persisted per RSN. */
    private volatile String authToken = null;

    /** Account hash of the currently logged-in player. Sent on every request. */
    private volatile long accountHash = -1;

    /**
     * Set the auth token after it has been loaded/generated by the plugin.
     * Must be called before any authenticated requests are made.
     */
    public void setAuthToken(String token) {
        this.authToken = token;
    }

    /**
     * Set the account hash for the currently logged-in player.
     * Sent as X-Account-Hash on every request so the backend can validate
     * HMAC(member_code, account_hash) for alt account support.
     */
    public void setAccountHash(long hash) {
        this.accountHash = hash;
    }

    // ======================================================================
    // PUBLIC API METHODS
    // ======================================================================

    /**
     * POST /api/auth/verify
     *
     * Authenticates the player. Sends account hash, RSN, account type, and optional owner tag.
     * Backend either finds existing member or auto-registers a new one.
     *
     * @param accountHash client.getAccountHash() value
     * @param rsn         player's RuneScape name
     * @param onSuccess   callback with AuthResponse on success
     * @param onError     callback with error message on failure
     */
    public void verifyMember(long accountHash, @Nonnull String rsn, @Nonnull String authToken,
                             @Nonnull Consumer<AuthResponse> onSuccess,
                             @Nonnull Consumer<String> onError) {
        if (config.devMode()) {
            AuthResponse devResponse = DevModeDataProvider.getAuthResponse(rsn);
            onSuccess.accept(devResponse);
            return;
        }

        String memberCode = config.memberCode();
        String json = gson.toJson(new VerifyRequest(rsn, authToken, memberCode));

        Request request = new Request.Builder()
            .url(ApiConstants.BACKEND_BASE_URL + "/auth/verify")
            .header("X-Account-Hash", String.valueOf(accountHash))
            .header("X-Member-Code", memberCode)
            .header("X-Auth-Token", authToken)
            .post(RequestBody.create(ApiConstants.JSON, json))
            .build();

        executeAsync(request, AuthResponse.class, onSuccess, onError);
    }

    /**
     * GET /api/plugin/config
     *
     * Fetches remote plugin configuration. Called by ConfigSyncService.
     *
     * @param memberCode the authenticated member's code
     * @param onSuccess  callback with PluginConfigResponse on success
     * @param onError    callback with error message on failure
     */
    public void fetchPluginConfig(@Nonnull String memberCode,
                                  @Nonnull Consumer<PluginConfigResponse> onSuccess,
                                  @Nonnull Consumer<String> onError) {
        if (config.devMode()) {
            PluginConfigResponse devConfig = DevModeDataProvider.getPluginConfig();
            onSuccess.accept(devConfig);
            return;
        }

        Request request = new Request.Builder()
            .url(ApiConstants.BACKEND_BASE_URL + "/plugin/config")
            .header("X-Member-Code", memberCode)
            .get()
            .build();

        executeAsync(request, PluginConfigResponse.Wrapper.class,
            wrapper -> {
                if (wrapper != null && wrapper.getConfig() != null) {
                    onSuccess.accept(wrapper.getConfig());
                } else {
                    onError.accept("Plugin config response missing 'config' field");
                }
            },
            onError
        );
    }

    /**
     * GET /api/members/me
     *
     * Fetches the authenticated member's profile.
     *
     * @param memberCode the authenticated member's code
     * @param onSuccess  callback with MemberProfile on success
     * @param onError    callback with error message on failure
     */
    public void fetchMemberProfile(@Nonnull String memberCode,
                                   @Nonnull Consumer<MemberProfile> onSuccess,
                                   @Nonnull Consumer<String> onError) {
        if (config.devMode()) {
            MemberProfile devProfile = DevModeDataProvider.getMemberProfile("DevPlayer");
            onSuccess.accept(devProfile);
            return;
        }

        Request request = new Request.Builder()
            .url(ApiConstants.BACKEND_BASE_URL + "/members/me")
            .header("X-Member-Code", memberCode)
            .get()
            .build();

        executeAsync(request, MemberProfile.class, onSuccess, onError);
    }

    // ======================================================================
    // ERROR STATE
    // ======================================================================

    /**
     * Reset degraded state. Call this when connectivity is restored
     * (e.g., a successful call comes through).
     */
    public void resetDegradedState() {
        consecutiveFailures.set(0);
        degraded = false;
    }

    /**
     * Clear the auth token on logout so stale tokens aren't sent.
     */
    public void clearAuthToken() {
        this.authToken = null;
        this.accountHash = -1;
    }

    // ======================================================================
    // INTERNAL HTTP EXECUTION
    // ======================================================================

    private <T> void executeAsync(Request request, Class<T> responseType,
                                  Consumer<T> onSuccess, Consumer<String> onError) {
        if (degraded) {
            onError.accept("Service degraded — using cached data");
            return;
        }

        // Inject X-Auth-Token and X-Account-Hash on every request.
        // X-Account-Hash is required on all authenticated endpoints so the backend
        // can recompute HMAC(member_code, account_hash) — this supports alt accounts
        // sharing the same member_code.
        Request.Builder builder = request.newBuilder();
        if (authToken != null && !authToken.isEmpty()) {
            builder.header("X-Auth-Token", authToken);
        }
        if (accountHash != -1) {
            builder.header("X-Account-Hash", String.valueOf(accountHash));
        }
        request = builder.build();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                handleFailure(e.getMessage(), onError);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (response) {
                    if (!response.isSuccessful()) {
                        handleFailure("HTTP " + response.code() + ": " + response.message(), onError);
                        return;
                    }

                    String body = response.body() != null ? response.body().string() : "";
                    T parsed = gson.fromJson(body, responseType);

                    // Reset failure counter on success
                    consecutiveFailures.set(0);
                    if (degraded) {
                        degraded = false;
                        log.info("Backend connectivity restored");
                    }

                    onSuccess.accept(parsed);
                } catch (Exception e) {
                    handleFailure("Parse error: " + e.getMessage(), onError);
                }
            }
        });
    }

    private void handleFailure(String message, Consumer<String> onError) {
        int failures = consecutiveFailures.incrementAndGet();
        int maxRetries = config.maxRetryAttempts();

        if (failures >= maxRetries && !degraded) {
            degraded = true;
            log.warn("Backend unreachable after {} attempts — entering degraded mode", failures);
        } else {
            log.warn("API call failed ({}/{}): {}", failures, maxRetries, message);
        }

        onError.accept(message);
    }

    // ======================================================================
    // PROFILE / LEADERBOARD / STATS METHODS
    // ======================================================================

    /**
     * GET /api/members/me
     *
     * Fetches the authenticated player's full profile.
     * Requires X-Member-Code header.
     *
     * @param onSuccess callback with PlayerProfile on success
     * @param onError   callback with error message on failure
     */
    public void fetchPlayerProfile(@Nonnull Consumer<PlayerProfile> onSuccess,
                                   @Nonnull Consumer<String> onError) {
        if (config.devMode()) {
            onSuccess.accept(DevModeDataProvider.getPlayerProfile("DevPlayer"));
            return;
        }

        String memberCode = config.memberCode();
        if (memberCode == null || memberCode.isEmpty()) {
            onError.accept("Not authenticated");
            return;
        }

        Request request = new Request.Builder()
            .url(ApiConstants.BACKEND_BASE_URL + "/members/me")
            .header("X-Member-Code", memberCode)
            .get()
            .build();

        executeAsync(request, PlayerProfile.class, onSuccess, onError);
    }

    /**
     * GET /api/leaderboard
     *
     * Fetches the clan leaderboard (points-based).
     *
     * @param page     page number (1-based)
     * @param perPage  results per page
     * @param onSuccess callback with LeaderboardResponse on success
     * @param onError   callback with error message on failure
     */
    public void fetchLeaderboard(int page, int perPage,
                                 @Nonnull Consumer<LeaderboardResponse> onSuccess,
                                 @Nonnull Consumer<String> onError) {
        if (config.devMode()) {
            onSuccess.accept(DevModeDataProvider.getLeaderboard(page, perPage));
            return;
        }

        Request request = new Request.Builder()
            .url(ApiConstants.BACKEND_BASE_URL + "/leaderboard?page=" + page + "&per_page=" + perPage)
            .get()
            .build();

        executeAsync(request, LeaderboardResponse.class, onSuccess, onError);
    }

    /**
     * GET /api/stats/clan/daily-xp
     *
     * Returns today's clan XP summary: top 3 players, top 3 skills, and active gainer count.
     * Uses UTC day boundaries. Requires X-Member-Code auth header.
     *
     * @param onSuccess callback with DailyXpResponse on success
     * @param onError   callback with error message on failure
     */
    public void fetchDailyXp(@Nonnull Consumer<com.boomerangbandits.api.models.DailyXpResponse> onSuccess,
                              @Nonnull Consumer<String> onError) {
        if (config.devMode()) {
            onSuccess.accept(new com.boomerangbandits.api.models.DailyXpResponse());
            return;
        }

        String memberCode = config.memberCode();
        if (memberCode == null || memberCode.isEmpty()) {
            onError.accept("Not authenticated");
            return;
        }

        Request request = new Request.Builder()
            .url(ApiConstants.BACKEND_BASE_URL + "/stats/clan/daily-xp")
            .header("X-Member-Code", memberCode)
            .get()
            .build();

        executeAsync(request, com.boomerangbandits.api.models.DailyXpResponse.class, onSuccess, onError);
    }

    /**
     * GET /api/members/me/player-challenges?incomplete=true
     *
     * Fetches the current player's active (incomplete) challenge.
     * Requires X-Member-Code auth header.
     *
     * @param onSuccess callback with PlayerChallenge on success
     * @param onError   callback with error message on failure
     */
    public void fetchPlayerChallenge(
            @Nonnull Consumer<com.boomerangbandits.api.models.PlayerChallenge> onSuccess,
            @Nonnull Consumer<String> onError) {
        if (config.devMode()) {
            onError.accept("No dev data for challenges");
            return;
        }

        String memberCode = config.memberCode();
        if (memberCode == null || memberCode.isEmpty()) {
            onError.accept("Not authenticated");
            return;
        }

        Request request = new Request.Builder()
            .url(ApiConstants.BACKEND_BASE_URL + "/members/me/player-challenges?incomplete=true")
            .header("X-Member-Code", memberCode)
            .get()
            .build();

        executeAsync(request, com.boomerangbandits.api.models.PlayerChallenge.class, onSuccess, onError);
    }

    /**
     * GET /api/members/ranks/summary
     *
     * Fetches rank summary (member count by rank).
     * Requires X-Member-Code header.
     *
     * @param includeZero whether to include ranks with zero members
     * @param onSuccess   callback with RankSummaryResponse on success
     * @param onError     callback with error message on failure
     */
    public void fetchRankSummary(boolean includeZero,
                                 @Nonnull Consumer<com.boomerangbandits.api.models.RankSummaryResponse> onSuccess,
                                 @Nonnull Consumer<String> onError) {
        if (config.devMode()) {
            onSuccess.accept(DevModeDataProvider.getRankSummary());
            return;
        }

        String memberCode = config.memberCode();
        if (memberCode == null || memberCode.isEmpty()) {
            onError.accept("Not authenticated");
            return;
        }

        Request request = new Request.Builder()
            .url(ApiConstants.BACKEND_BASE_URL + "/members/ranks/summary?include_zero=" + includeZero)
            .header("X-Member-Code", memberCode)
            .get()
            .build();

        executeAsync(request, com.boomerangbandits.api.models.RankSummaryResponse.class, onSuccess, onError);
    }

    // ======================================================================
    // INNER CLASSES (request bodies and response wrappers)
    // ======================================================================

    /**
     * Request body for POST /api/auth/verify
     */
    private static class VerifyRequest {
        private final String rsn;
        private final String authToken;
        private final String memberCode;

        VerifyRequest(String rsn, String authToken, String memberCode) {
            this.rsn = rsn;
            this.authToken = authToken;
            this.memberCode = memberCode;
        }
    }

    /**
     * Wrapper for paginated leaderboard response.
     */
    @Setter
    @Getter
    public static class LeaderboardResponse {
        private List<LeaderboardEntry> leaderboard;
        private int total;
        private int page;
        private int pages;

    }
}
